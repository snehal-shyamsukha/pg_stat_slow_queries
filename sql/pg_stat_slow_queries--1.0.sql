CREATE SCHEMA IF NOT EXISTS monitoring;

-- slow queries table (schema supplied at install)
CREATE TABLE monitoring.pg_stat_slow_queries (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  captured_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  pid integer NOT NULL,
  datid oid,
  datname text,
  usename text,
  application_name text,
  client_addr inet,
  client_port integer,
  backend_start timestamptz,
  xact_start timestamptz,
  query_start timestamptz NOT NULL,
  state text,
  wait_event_type text[],
  wait_event text[],
  backend_type text,
  queryid bigint,
  query text,
  duration_running interval NOT NULL,
  memory_consumption_kb integer,
  CONSTRAINT uq_pid_querystart UNIQUE (pid, query_start)
);

GRANT SELECT ON monitoring.pg_stat_slow_queries to public;

-- Logger function
CREATE OR REPLACE FUNCTION monitoring.log_slow_queries(threshold_seconds integer DEFAULT 10)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  rows_inserted integer := 0;
BEGIN
  INSERT INTO monitoring.pg_stat_slow_queries (
    pid, datid, datname, usename, application_name, client_addr, client_port,
    backend_start, xact_start, query_start, state, wait_event_type, wait_event,
    backend_type, queryid, query, duration_running
  )
  SELECT
    a.pid, a.datid, a.datname, a.usename, a.application_name, a.client_addr, a.client_port,
    a.backend_start, a.xact_start, a.query_start, a.state,
    ARRAY[a.wait_event_type], ARRAY[a.wait_event],
    a.backend_type, a.query_id, a.query,
    (now() - a.query_start) AS duration_running
  FROM pg_catalog.pg_stat_activity a
  WHERE a.state in ('active','idle in transaction','idle in transaction (aborted)')
    AND a.backend_type = 'client backend'
    AND a.query_start IS NOT NULL
    AND (now() - a.query_start) >= make_interval(secs => threshold_seconds)
  ON CONFLICT ON CONSTRAINT uq_pid_querystart DO UPDATE
    SET duration_running = EXCLUDED.duration_running,
        wait_event_type = CASE
          WHEN monitoring.pg_stat_slow_queries.wait_event_type IS NULL
            OR monitoring.pg_stat_slow_queries.wait_event_type[array_length(monitoring.pg_stat_slow_queries.wait_event_type, 1)]
               IS DISTINCT FROM EXCLUDED.wait_event_type[1]
          THEN array_append(monitoring.pg_stat_slow_queries.wait_event_type, EXCLUDED.wait_event_type[1])
          ELSE monitoring.pg_stat_slow_queries.wait_event_type
        END,
        wait_event = CASE
          WHEN monitoring.pg_stat_slow_queries.wait_event IS NULL
            OR monitoring.pg_stat_slow_queries.wait_event[array_length(monitoring.pg_stat_slow_queries.wait_event, 1)]
               IS DISTINCT FROM EXCLUDED.wait_event[1]
          THEN array_append(monitoring.pg_stat_slow_queries.wait_event, EXCLUDED.wait_event[1])
          ELSE monitoring.pg_stat_slow_queries.wait_event
        END,
        updated_at = now();

  GET DIAGNOSTICS rows_inserted = ROW_COUNT;
  RETURN rows_inserted;
END;
$$;

-- Indexes
CREATE INDEX ON monitoring.pg_stat_slow_queries (query_start);
CREATE INDEX ON monitoring.pg_stat_slow_queries (duration_running);

-- Optional: helper to register a cron job (requires superuser and pg_cron)
CREATE OR REPLACE FUNCTION monitoring.schedule_logger(job_name text DEFAULT 'log-slow-queries', interval_text text DEFAULT '3 seconds', threshold_seconds integer DEFAULT 10)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM cron.schedule(job_name, interval_text, format('SELECT monitoring.log_slow_queries(%L);', threshold_seconds));
END;
$$;
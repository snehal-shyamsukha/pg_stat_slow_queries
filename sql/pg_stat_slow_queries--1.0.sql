CREATE SCHEMA IF NOT EXISTS monitoring;

-- slow queries table (schema supplied at install)
CREATE TABLE monitoring.pg_stat_slow_queries (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  captured_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  pid integer NOT NULL,
  datid oid,
  datname text,
  usename text,
  application_name text,
  client_addr inet,
  client_port integer,
  backend_start timestamptz,
  xact_start timestamptz,
  query_start timestamptz NOT NULL,
  state text,
  wait_event_type text[],
  wait_event text[],
  backend_type text,
  queryid bigint,
  query text,
  duration_running interval NOT NULL,
  memory_consumption_kb integer,
  CONSTRAINT uq_pid_querystart UNIQUE (pid, query_start)
);

CREATE TABLE monitoring.pg_stat_db_connections (
    bucket_time TIMESTAMPTZ NOT NULL,                  -- Start of 5-min bucket (e.g., 13:00:00)
    usename TEXT NOT NULL,                             -- Database user
    datname TEXT NOT NULL,                             -- Database name
    backend_type TEXT NOT NULL,                      
    state TEXT,                               
    connection_count INTEGER,
    avg_query_durations INTERVAL[] DEFAULT '{}',
    max_query_durations INTERVAL[] DEFAULT '{}',
    client_addrs TEXT[] DEFAULT '{}',
    memory_consumption_kb INTEGER,
    PRIMARY KEY (usename, datname, backend_type,state, bucket_time)
);

GRANT SELECT ON monitoring.pg_stat_slow_queries to public;
GRANT SELECT ON monitoring.pg_stat_db_connections to public;

-- Logger function
CREATE OR REPLACE FUNCTION monitoring.log_slow_queries(threshold_seconds integer DEFAULT 10)
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
  rows_inserted integer := 0;
BEGIN
  INSERT INTO monitoring.pg_stat_slow_queries (
    pid, datid, datname, usename, application_name, client_addr, client_port,
    backend_start, xact_start, query_start, state, wait_event_type, wait_event,
    backend_type, queryid, query, duration_running
  )
  SELECT
    a.pid, a.datid, a.datname, a.usename, a.application_name, a.client_addr, a.client_port,
    a.backend_start, a.xact_start, a.query_start, a.state,
    ARRAY[a.wait_event_type], ARRAY[a.wait_event],
    a.backend_type, a.query_id, a.query,
    (now() - a.query_start) AS duration_running
  FROM pg_catalog.pg_stat_activity a
  WHERE a.state in ('active','idle in transaction','idle in transaction (aborted)')
    AND a.backend_type = 'client backend'
    AND a.query_start IS NOT NULL
    AND (now() - a.query_start) >= make_interval(secs => threshold_seconds)
  ON CONFLICT ON CONSTRAINT uq_pid_querystart DO UPDATE
    SET duration_running = EXCLUDED.duration_running,
        wait_event_type = CASE
          WHEN monitoring.pg_stat_slow_queries.wait_event_type IS NULL
            OR monitoring.pg_stat_slow_queries.wait_event_type[array_length(monitoring.pg_stat_slow_queries.wait_event_type, 1)]
               IS DISTINCT FROM EXCLUDED.wait_event_type[1]
          THEN array_append(monitoring.pg_stat_slow_queries.wait_event_type, EXCLUDED.wait_event_type[1])
          ELSE monitoring.pg_stat_slow_queries.wait_event_type
        END,
        wait_event = CASE
          WHEN monitoring.pg_stat_slow_queries.wait_event IS NULL
            OR monitoring.pg_stat_slow_queries.wait_event[array_length(monitoring.pg_stat_slow_queries.wait_event, 1)]
               IS DISTINCT FROM EXCLUDED.wait_event[1]
          THEN array_append(monitoring.pg_stat_slow_queries.wait_event, EXCLUDED.wait_event[1])
          ELSE monitoring.pg_stat_slow_queries.wait_event
        END,
        updated_at = now();

  GET DIAGNOSTICS rows_inserted = ROW_COUNT;
  RETURN rows_inserted;
END;
$$;

CREATE OR REPLACE FUNCTION monitoring.collect_connection_stats() RETURNS void AS $$
BEGIN
    INSERT INTO monitoring.pg_stat_db_connections (
        bucket_time,
        usename,
        datname,
        backend_type,
        state,
        connection_count,
        avg_query_durations,
        max_query_durations,
        client_addrs
    )
    SELECT
        now(),
        sa.usename,
        sa.datname,
        sa.backend_type,
        sa.state,
        COUNT(*),
        ARRAY[AVG(now() - sa.query_start)],
        ARRAY[MAX(now() - sa.query_start)],
        ARRAY_AGG(DISTINCT sa.client_addr)
    FROM pg_stat_activity sa
    WHERE sa.state is not null 
    GROUP BY sa.usename, sa.datname, sa.backend_type, sa.state;
END;
$$ LANGUAGE plpgsql;


-- Indexes
CREATE INDEX ON monitoring.pg_stat_slow_queries (query_start);
CREATE INDEX ON monitoring.pg_stat_slow_queries (duration_running);
CREATE INDEX idx_connection_capture_time on monitoring.pg_stat_db_connections(bucket_time);
CREATE INDEX idx_connection_connection_counts on monitoring.pg_stat_db_connections(connection_count);

-- Optional: helper to register a cron job (requires superuser and pg_cron)
CREATE OR REPLACE FUNCTION monitoring.schedule_logger(job_name text DEFAULT 'log-slow-queries', interval_text text DEFAULT '3 seconds', threshold_seconds integer DEFAULT 10)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM cron.schedule(job_name, interval_text, format('SELECT monitoring.log_slow_queries(%L);', threshold_seconds));
END;
$$;

-- Optional: helper to register a cron to schedule connection logging
CREATE OR REPLACE FUNCTION monitoring.schedule_connection_logger(job_name text DEFAULT 'log-connections', interval_text text DEFAULT '30 seconds')
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  PERFORM cron.schedule(job_name, interval_text, 'SELECT monitoring.collect_connection_stats();');
END;
$$;
